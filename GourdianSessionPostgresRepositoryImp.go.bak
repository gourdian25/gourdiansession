package gourdiansession

// import (
// 	"context"
// 	"errors"
// 	"time"

// 	"github.com/google/uuid"
// 	"github.com/gourdian25/gourdiansession/errs"
// 	"gorm.io/gorm"
// )

// MigrateAndIndexSessionTable runs auto-migration for the session table.
// Indexes are automatically created based on struct tags.
// func MigrateAndIndexSessionTable(ctx context.Context, db *gorm.DB) error {
// 	return db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
// 		// AutoMigrate will create indexes based on the struct tags
// 		if err := tx.AutoMigrate(&SessionType{}); err != nil {
// 			return errs.RepositoryError("MigrateAndIndexSessionTable", err, "failed to auto-migrate session table")
// 		}

// 		log.Println("Session table migration completed successfully")
// 		return nil
// 	})
// }

// type SessionPostgresRepository struct {
// 	db *gorm.DB
// }

// func NewSessionPostgresRepository(db *gorm.DB) SessionRepositoryInt {
// 	return &SessionPostgresRepository{db: db}
// }

// func (r *SessionPostgresRepository) withTransaction(ctx context.Context, fn func(tx *gorm.DB) error) error {
// 	tx := r.db.WithContext(ctx).Begin()
// 	if tx.Error != nil {
// 		return errs.RepositoryError("WithTransaction", tx.Error, "failed to begin transaction")
// 	}

// 	if err := fn(tx); err != nil {
// 		tx.Rollback()
// 		return err
// 	}

// 	if err := tx.Commit().Error; err != nil {
// 		return errs.RepositoryError("WithTransaction", err, "failed to commit transaction")
// 	}

// 	return nil
// }

// // Session lifecycle methods

// func (r *SessionPostgresRepository) CreateSession(ctx context.Context, session *SessionType) (*SessionType, error) {
// 	var createdSession SessionType

// 	err := r.withTransaction(ctx, func(tx *gorm.DB) error {
// 		if err := tx.Create(session).Error; err != nil {
// 			return errs.RepositoryError("CreateSession", err, "failed to create session")
// 		}

// 		if err := tx.First(&createdSession, "session_id = ?", session.SessionID).Error; err != nil {
// 			return errs.RepositoryError("CreateSession", err, "failed to fetch created session")
// 		}

// 		return nil
// 	})

// 	if err != nil {
// 		return nil, err
// 	}

// 	return &createdSession, nil
// }

// func (r *SessionPostgresRepository) RevokeSessionByID(ctx context.Context, sessionID uuid.UUID) error {
// 	return r.withTransaction(ctx, func(tx *gorm.DB) error {
// 		result := tx.Model(&SessionType{}).
// 			Where("session_id = ? AND status = ?", sessionID, SessionStatusActive).
// 			Updates(map[string]interface{}{
// 				"status":     SessionStatusRevoked,
// 				"deleted_at": time.Now(),
// 				"expires_at": time.Now(),
// 				"updated_at": time.Now(),
// 			})

// 		if result.Error != nil {
// 			return errs.RepositoryError("RevokeSessionByID", result.Error, "failed to revoke session")
// 		}
// 		if result.RowsAffected == 0 {
// 			return errs.RepositoryError("RevokeSessionByID", errs.ErrNotFound, "session not found or already revoked")
// 		}
// 		return nil
// 	})
// }

// func (r *SessionPostgresRepository) GetSessionByID(ctx context.Context, sessionID uuid.UUID) (*SessionType, error) {
// 	var session SessionType

// 	if err := r.db.WithContext(ctx).
// 		Where("session_id = ? AND status = ? AND deleted_at IS NULL", sessionID, SessionStatusActive).
// 		First(&session).Error; err != nil {
// 		if errors.Is(err, gorm.ErrRecordNotFound) {
// 			return nil, errs.RepositoryError("GetSessionByID", errs.ErrNotFound, "session not found")
// 		}
// 		return nil, errs.RepositoryError("GetSessionByID", err, "failed to get session")
// 	}

// 	if time.Now().After(session.ExpiresAt) {
// 		return nil, errs.RepositoryError("GetSessionByID", errs.ErrNotFound, "session expired")
// 	}

// 	return &session, nil
// }

// func (r *SessionPostgresRepository) UpdateSession(ctx context.Context, session *SessionType) (*SessionType, error) {
// 	var updatedSession SessionType

// 	err := r.withTransaction(ctx, func(tx *gorm.DB) error {
// 		if err := tx.Model(session).
// 			Where("session_id = ?", session.SessionID).
// 			Updates(session).Error; err != nil {
// 			return errs.RepositoryError("UpdateSession", err, "failed to update session")
// 		}

// 		if err := tx.First(&updatedSession, "session_id = ?", session.SessionID).Error; err != nil {
// 			return errs.RepositoryError("UpdateSession", err, "failed to fetch updated session")
// 		}

// 		return nil
// 	})

// 	if err != nil {
// 		return nil, err
// 	}

// 	return &updatedSession, nil
// }

// func (r *SessionPostgresRepository) DeleteSession(ctx context.Context, sessionID uuid.UUID) error {
// 	return r.withTransaction(ctx, func(tx *gorm.DB) error {
// 		result := tx.Model(&SessionType{}).
// 			Where("session_id = ?", sessionID).
// 			Update("deleted_at", time.Now())

// 		if result.Error != nil {
// 			return errs.RepositoryError("DeleteSession", result.Error, "failed to delete session")
// 		}
// 		if result.RowsAffected == 0 {
// 			return errs.RepositoryError("DeleteSession", errs.ErrNotFound, "session not found")
// 		}
// 		return nil
// 	})
// }

// func (r *SessionPostgresRepository) GetSessionsByUserID(ctx context.Context, userID uuid.UUID) ([]*SessionType, error) {
// 	var sessions []*SessionType

// 	if err := r.db.WithContext(ctx).
// 		Where("user_id = ? AND deleted_at IS NULL", userID).
// 		Find(&sessions).Error; err != nil {
// 		return nil, errs.RepositoryError("GetSessionsByUserID", err, "failed to get sessions")
// 	}

// 	return sessions, nil
// }

// func (r *SessionPostgresRepository) GetActiveSessionsByUserID(ctx context.Context, userID uuid.UUID) ([]*SessionType, error) {
// 	var sessions []*SessionType

// 	if err := r.db.WithContext(ctx).
// 		Where("user_id = ? AND status = ? AND deleted_at IS NULL", userID, SessionStatusActive).
// 		Find(&sessions).Error; err != nil {
// 		return nil, errs.RepositoryError("GetActiveSessionsByUserID", err, "failed to get active sessions")
// 	}

// 	// Filter out expired sessions
// 	var activeSessions []*SessionType
// 	now := time.Now()
// 	for _, session := range sessions {
// 		if session.ExpiresAt.After(now) {
// 			activeSessions = append(activeSessions, session)
// 		}
// 	}

// 	return activeSessions, nil
// }

// func (r *SessionPostgresRepository) RevokeUserSessions(ctx context.Context, userID uuid.UUID) error {
// 	return r.withTransaction(ctx, func(tx *gorm.DB) error {
// 		result := tx.Model(&SessionType{}).
// 			Where("user_id = ? AND status = ?", userID, SessionStatusActive).
// 			Updates(map[string]interface{}{
// 				"status":     SessionStatusRevoked,
// 				"deleted_at": time.Now(),
// 				"expires_at": time.Now(),
// 				"updated_at": time.Now(),
// 			})

// 		if result.Error != nil {
// 			return errs.RepositoryError("RevokeUserSessions", result.Error, "failed to revoke user sessions")
// 		}
// 		return nil
// 	})
// }

// func (r *SessionPostgresRepository) RevokeSessionsExcept(ctx context.Context, userID, exceptSessionID uuid.UUID) error {
// 	return r.withTransaction(ctx, func(tx *gorm.DB) error {
// 		result := tx.Model(&SessionType{}).
// 			Where("user_id = ? AND status = ? AND session_id != ?", userID, SessionStatusActive, exceptSessionID).
// 			Updates(map[string]interface{}{
// 				"status":     SessionStatusRevoked,
// 				"deleted_at": time.Now(),
// 				"expires_at": time.Now(),
// 				"updated_at": time.Now(),
// 			})

// 		if result.Error != nil {
// 			return errs.RepositoryError("RevokeSessionsExcept", result.Error, "failed to revoke sessions")
// 		}
// 		return nil
// 	})
// }

// func (r *SessionPostgresRepository) ExtendSession(ctx context.Context, sessionID uuid.UUID, duration time.Duration) error {
// 	return r.withTransaction(ctx, func(tx *gorm.DB) error {
// 		result := tx.Model(&SessionType{}).
// 			Where("session_id = ? AND status = ?", sessionID, SessionStatusActive).
// 			Updates(map[string]interface{}{
// 				"expires_at": time.Now().Add(duration),
// 				"updated_at": time.Now(),
// 			})

// 		if result.Error != nil {
// 			return errs.RepositoryError("ExtendSession", result.Error, "failed to extend session")
// 		}
// 		if result.RowsAffected == 0 {
// 			return errs.RepositoryError("ExtendSession", errs.ErrNotFound, "session not found or not active")
// 		}
// 		return nil
// 	})
// }

// func (r *SessionPostgresRepository) UpdateSessionActivity(ctx context.Context, sessionID uuid.UUID) error {
// 	return r.withTransaction(ctx, func(tx *gorm.DB) error {
// 		result := tx.Model(&SessionType{}).
// 			Where("session_id = ? AND status = ?", sessionID, SessionStatusActive).
// 			Update("last_activity", time.Now())

// 		if result.Error != nil {
// 			return errs.RepositoryError("UpdateSessionActivity", result.Error, "failed to update session activity")
// 		}
// 		if result.RowsAffected == 0 {
// 			return errs.RepositoryError("UpdateSessionActivity", errs.ErrNotFound, "session not found or not active")
// 		}
// 		return nil
// 	})
// }

// func (r *SessionPostgresRepository) ValidateSessionByID(ctx context.Context, sessionID uuid.UUID) (*SessionType, error) {
// 	session, err := r.GetSessionByID(ctx, sessionID)
// 	if err != nil {
// 		return nil, err
// 	}

// 	if session.Status != SessionStatusActive {
// 		return nil, errs.RepositoryError("ValidateSessionByID", errs.ErrInvalidSession, "session not active")
// 	}

// 	if time.Now().After(session.ExpiresAt) {
// 		return nil, errs.RepositoryError("ValidateSessionByID", errs.ErrInvalidSession, "session expired")
// 	}

// 	return session, nil
// }

// func (r *SessionPostgresRepository) ValidateSessionByIDIPUA(ctx context.Context, sessionID uuid.UUID, ipAddress, userAgent string) (*SessionType, error) {
// 	session, err := r.GetSessionByID(ctx, sessionID)
// 	if err != nil {
// 		return nil, err
// 	}

// 	if session.Status != SessionStatusActive {
// 		return nil, errs.RepositoryError("ValidateSessionByIDIPUA", errs.ErrInvalidSession, "session not active")
// 	}

// 	if time.Now().After(session.ExpiresAt) {
// 		return nil, errs.RepositoryError("ValidateSessionByIDIPUA", errs.ErrInvalidSession, "session expired")
// 	}

// 	if session.IPAddress != nil && *session.IPAddress != ipAddress {
// 		return nil, errs.RepositoryError("ValidateSessionByIDIPUA", errs.ErrInvalidSession, "IP address mismatch")
// 	}

// 	if session.UserAgent != nil && *session.UserAgent != userAgent {
// 		return nil, errs.RepositoryError("ValidateSessionByIDIPUA", errs.ErrInvalidSession, "user agent mismatch")
// 	}

// 	return session, nil
// }

// // Session data methods

// func (r *SessionPostgresRepository) SetSessionData(ctx context.Context, sessionID uuid.UUID, key string, value interface{}) error {
// 	// In a real implementation, this would store data in a separate session_data table
// 	// For this example, we'll update the TempData field which is runtime-only
// 	return r.withTransaction(ctx, func(tx *gorm.DB) error {
// 		var session SessionType
// 		if err := tx.First(&session, "session_id = ?", sessionID).Error; err != nil {
// 			return errs.RepositoryError("SetSessionData", err, "session not found")
// 		}

// 		if session.TempData == nil {
// 			session.TempData = &map[string]interface{}{}
// 		}
// 		(*session.TempData)[key] = value

// 		if err := tx.Model(&session).Update("temp_data", session.TempData).Error; err != nil {
// 			return errs.RepositoryError("SetSessionData", err, "failed to update session data")
// 		}

// 		return nil
// 	})
// }

// func (r *SessionPostgresRepository) GetSessionData(ctx context.Context, sessionID uuid.UUID, key string) (interface{}, error) {
// 	var session SessionType
// 	if err := r.db.WithContext(ctx).
// 		First(&session, "session_id = ?", sessionID).Error; err != nil {
// 		return nil, errs.RepositoryError("GetSessionData", err, "session not found")
// 	}

// 	if session.TempData == nil {
// 		return nil, errs.RepositoryError("GetSessionData", errs.ErrNotFound, "data not found")
// 	}

// 	value, exists := (*session.TempData)[key]
// 	if !exists {
// 		return nil, errs.RepositoryError("GetSessionData", errs.ErrNotFound, "data not found")
// 	}

// 	return value, nil
// }

// func (r *SessionPostgresRepository) DeleteSessionData(ctx context.Context, sessionID uuid.UUID, key string) error {
// 	return r.withTransaction(ctx, func(tx *gorm.DB) error {
// 		var session SessionType
// 		if err := tx.First(&session, "session_id = ?", sessionID).Error; err != nil {
// 			return errs.RepositoryError("DeleteSessionData", err, "session not found")
// 		}

// 		if session.TempData == nil {
// 			return nil
// 		}

// 		delete(*session.TempData, key)

// 		if err := tx.Model(&session).Update("temp_data", session.TempData).Error; err != nil {
// 			return errs.RepositoryError("DeleteSessionData", err, "failed to update session data")
// 		}

// 		return nil
// 	})
// }

// // Temporary data methods (would typically use Redis or similar in production)

// func (r *SessionPostgresRepository) SetTemporaryData(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
// 	// In a real implementation, this would use Redis or similar
// 	// For this example, we'll just store it in memory (not persistent)
// 	return errs.RepositoryError("SetTemporaryData", errs.ErrNotImplemented, "temporary data storage not implemented")
// }

// func (r *SessionPostgresRepository) GetTemporaryData(ctx context.Context, key string) (interface{}, error) {
// 	// In a real implementation, this would use Redis or similar
// 	return nil, errs.RepositoryError("GetTemporaryData", errs.ErrNotImplemented, "temporary data storage not implemented")
// }

// func (r *SessionPostgresRepository) DeleteTemporaryData(ctx context.Context, key string) error {
// 	// In a real implementation, this would use Redis or similar
// 	return errs.RepositoryError("DeleteTemporaryData", errs.ErrNotImplemented, "temporary data storage not implemented")
// }

























import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/gourdian25/gourdiansession/errs"
	"github.com/redis/go-redis/v9"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
)

type SessionServiceTestSuite struct {
	suite.Suite
	client     *redis.Client
	repository GurdianSessionRepositoryInt
	service    GourdianSessionServiceInt
	ctx        context.Context
}

func (suite *SessionServiceTestSuite) SetupSuite() {
	suite.client = redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "GourdianRedisSecret",
		DB:       0,
	})
	suite.repository = NewGurdianRedisSessionRepository(suite.client)

	config := &GourdianSessionConfig{
		MaxUserSessions:            5,
		MaxSessionsPerDevice:       3,
		MaxIPConnections:           2,
		AllowConcurrentSessions:    false,
		TrackIPAddresses:           true,
		TrackClientDevices:         true,
		DefaultSessionDuration:     1 * time.Hour,
		IdleTimeoutDuration:        30 * time.Minute,
		SessionRenewalWindow:       15 * time.Minute,
		SessionCleanupInterval:     1 * time.Hour,
		AutoRevokeOnPasswordChange: true,
		BlockedUserAgents:          []string{"bad-bot", "scraper"},
	}

	suite.service = NewGourdianSessionService(suite.repository, config)
	suite.ctx = context.Background()

	// Flush DB before tests
	err := suite.client.FlushDB(suite.ctx).Err()
	assert.NoError(suite.T(), err)
}

func (suite *SessionServiceTestSuite) TearDownTest() {
	// Flush DB after each test
	err := suite.client.FlushDB(suite.ctx).Err()
	assert.NoError(suite.T(), err)
}

func (suite *SessionServiceTestSuite) TestCreateSession() {
	userID := uuid.New()
	username := "testuser"
	ipAddress := "192.168.1.1"
	userAgent := "test-agent"
	roles := []Role{
		{
			Name: "admin",
			Permissions: []Permission{
				{
					Name:     "read",
					Resource: "users",
					Action:   "read",
				},
			},
		},
	}

	// Create a new session
	session, err := suite.service.CreateSession(suite.ctx, userID, username, &ipAddress, &userAgent, roles)
	assert.NoError(suite.T(), err)
	assert.NotNil(suite.T(), session)
	assert.Equal(suite.T(), username, session.Username)
	assert.Equal(suite.T(), userID, session.UserID)
	assert.Equal(suite.T(), ipAddress, *session.IPAddress)
	assert.Equal(suite.T(), userAgent, *session.UserAgent)
	assert.Equal(suite.T(), SessionStatusActive, session.Status)
	assert.True(suite.T(), session.Authenticated)

	// Verify concurrent sessions are not allowed (based on config)
	otherSessions, err := suite.service.GetActiveUserSessions(suite.ctx, userID)
	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), otherSessions, 1) // Only the current session should exist
}

func (suite *SessionServiceTestSuite) TestCreateSessionWithBlockedUserAgent() {
	userID := uuid.New()
	username := "testuser"
	ipAddress := "192.168.1.1"
	blockedUserAgent := "bad-bot/1.0"
	roles := []Role{}

	// Try to create session with blocked user agent
	_, err := suite.service.CreateSession(suite.ctx, userID, username, &ipAddress, &blockedUserAgent, roles)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrForbidden, err)
}

func (suite *SessionServiceTestSuite) TestRevokeSession() {
	userID := uuid.New()
	session, err := suite.service.CreateSession(suite.ctx, userID, "testuser", nil, nil, nil)
	assert.NoError(suite.T(), err)

	// Revoke the session
	err = suite.service.RevokeSession(suite.ctx, session.UUID)
	assert.NoError(suite.T(), err)

	// Verify session is revoked
	revokedSession, err := suite.service.GetSession(suite.ctx, session.UUID)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), SessionStatusRevoked, revokedSession.Status)
}

func (suite *SessionServiceTestSuite) TestGetSession() {
	userID := uuid.New()
	createdSession, err := suite.service.CreateSession(suite.ctx, userID, "testuser", nil, nil, nil)
	assert.NoError(suite.T(), err)

	// Get the session
	retrievedSession, err := suite.service.GetSession(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), createdSession.UUID, retrievedSession.UUID)
	assert.Equal(suite.T(), createdSession.UserID, retrievedSession.UserID)
	assert.Equal(suite.T(), createdSession.Username, retrievedSession.Username)
}

func (suite *SessionServiceTestSuite) TestRefreshSession() {
	userID := uuid.New()
	createdSession, err := suite.service.CreateSession(suite.ctx, userID, "testuser", nil, nil, nil)
	assert.NoError(suite.T(), err)

	// Manually set expiry to be within renewal window
	createdSession.ExpiresAt = time.Now().Add(10 * time.Minute) // Within 15min renewal window
	_, err = suite.repository.UpdateSession(suite.ctx, createdSession)
	assert.NoError(suite.T(), err)

	// Refresh session
	refreshedSession, err := suite.service.RefreshSession(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)
	assert.True(suite.T(), refreshedSession.ExpiresAt.After(createdSession.ExpiresAt))
	assert.WithinDuration(suite.T(), time.Now().Add(suite.service.(*GourdianSessionService).config.DefaultSessionDuration),
		refreshedSession.ExpiresAt, time.Second)
}

func (suite *SessionServiceTestSuite) TestExtendSession() {
	userID := uuid.New()
	createdSession, err := suite.service.CreateSession(suite.ctx, userID, "testuser", nil, nil, nil)
	assert.NoError(suite.T(), err)

	originalExpiry := createdSession.ExpiresAt

	// Extend session by 2 hours
	extendedSession, err := suite.service.ExtendSession(suite.ctx, createdSession.UUID, 2*time.Hour)
	assert.NoError(suite.T(), err)
	assert.True(suite.T(), extendedSession.ExpiresAt.After(originalExpiry))
	assert.WithinDuration(suite.T(), originalExpiry.Add(2*time.Hour), extendedSession.ExpiresAt, time.Second)
}

func (suite *SessionServiceTestSuite) TestUpdateSessionActivity() {
	userID := uuid.New()
	createdSession, err := suite.service.CreateSession(suite.ctx, userID, "testuser", nil, nil, nil)
	assert.NoError(suite.T(), err)

	originalActivity := createdSession.LastActivity

	// Wait a bit to ensure time changes
	time.Sleep(10 * time.Millisecond)

	// Update activity
	err = suite.service.UpdateSessionActivity(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)

	// Verify update
	updatedSession, err := suite.service.GetSession(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)
	assert.True(suite.T(), updatedSession.LastActivity.After(originalActivity))
}

func (suite *SessionServiceTestSuite) TestGetUserSessions() {
	userID := uuid.New()
	otherUserID := uuid.New()

	// Create 3 sessions for user
	for i := 0; i < 3; i++ {
		_, err := suite.service.CreateSession(suite.ctx, userID, "testuser", nil, nil, nil)
		assert.NoError(suite.T(), err)
	}

	// Create 2 sessions for other user
	for i := 0; i < 2; i++ {
		_, err := suite.service.CreateSession(suite.ctx, otherUserID, "otheruser", nil, nil, nil)
		assert.NoError(suite.T(), err)
	}

	// Get sessions for user
	sessions, err := suite.service.GetUserSessions(suite.ctx, userID)
	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), sessions, 3)
	for _, session := range sessions {
		assert.Equal(suite.T(), userID, session.UserID)
	}

	// Get sessions for other user
	otherSessions, err := suite.service.GetUserSessions(suite.ctx, otherUserID)
	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), otherSessions, 2)
	for _, session := range otherSessions {
		assert.Equal(suite.T(), otherUserID, session.UserID)
	}
}

func (suite *SessionServiceTestSuite) TestGetActiveUserSessions() {
	userID := uuid.New()

	// Create 2 active sessions
	for i := 0; i < 2; i++ {
		_, err := suite.service.CreateSession(suite.ctx, userID, "testuser", nil, nil, nil)
		assert.NoError(suite.T(), err)
	}

	// Create an expired session (by creating with negative duration)
	expiredSession := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		-1*time.Hour,
	)
	_, err := suite.repository.CreateSession(suite.ctx, expiredSession)
	assert.NoError(suite.T(), err)

	// Get active sessions
	activeSessions, err := suite.service.GetActiveUserSessions(suite.ctx, userID)
	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), activeSessions, 2)
	for _, session := range activeSessions {
		assert.Equal(suite.T(), SessionStatusActive, session.Status)
		assert.True(suite.T(), session.ExpiresAt.After(time.Now()))
	}
}

func (suite *SessionServiceTestSuite) TestRevokeAllUserSessions() {
	userID := uuid.New()

	// Create 3 active sessions
	for i := 0; i < 3; i++ {
		_, err := suite.service.CreateSession(suite.ctx, userID, "testuser", nil, nil, nil)
		assert.NoError(suite.T(), err)
	}

	// Revoke all sessions
	err := suite.service.RevokeAllUserSessions(suite.ctx, userID)
	assert.NoError(suite.T(), err)

	// Verify all sessions are revoked
	sessions, err := suite.service.GetUserSessions(suite.ctx, userID)
	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), sessions, 3)
	for _, session := range sessions {
		assert.Equal(suite.T(), SessionStatusRevoked, session.Status)
	}
}

func (suite *SessionServiceTestSuite) TestRevokeOtherUserSessions() {
	userID := uuid.New()
	var keepSessionID uuid.UUID

	// Create 3 active sessions
	for i := 0; i < 3; i++ {
		session, err := suite.service.CreateSession(suite.ctx, userID, "testuser", nil, nil, nil)
		assert.NoError(suite.T(), err)
		if i == 1 {
			keepSessionID = session.UUID
		}
	}

	// Revoke other sessions
	err := suite.service.RevokeOtherUserSessions(suite.ctx, userID, keepSessionID)
	assert.NoError(suite.T(), err)

	// Verify sessions
	sessions, err := suite.service.GetUserSessions(suite.ctx, userID)
	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), sessions, 3)

	var keptSession *GourdianSessionType
	for _, session := range sessions {
		if session.UUID == keepSessionID {
			keptSession = session
			assert.Equal(suite.T(), SessionStatusActive, session.Status)
		} else {
			assert.Equal(suite.T(), SessionStatusRevoked, session.Status)
		}
	}
	assert.NotNil(suite.T(), keptSession)
}

func (suite *SessionServiceTestSuite) TestValidateSession() {
	userID := uuid.New()
	createdSession, err := suite.service.CreateSession(suite.ctx, userID, "testuser", nil, nil, nil)
	assert.NoError(suite.T(), err)

	// Validate active session
	validSession, err := suite.service.ValidateSession(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), createdSession.UUID, validSession.UUID)
	assert.Equal(suite.T(), SessionStatusActive, validSession.Status)

	// Create an expired session
	expiredSession := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		-1*time.Hour,
	)
	createdExpiredSession, err := suite.repository.CreateSession(suite.ctx, expiredSession)
	assert.NoError(suite.T(), err)

	// Validate expired session
	_, err = suite.service.ValidateSession(suite.ctx, createdExpiredSession.UUID)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrInvalidSession, err)

	// Create a revoked session
	revokedSession := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		1*time.Hour,
	)
	revokedSession.Status = SessionStatusRevoked
	createdRevokedSession, err := suite.repository.CreateSession(suite.ctx, revokedSession)
	assert.NoError(suite.T(), err)

	// Validate revoked session
	_, err = suite.service.ValidateSession(suite.ctx, createdRevokedSession.UUID)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrInvalidSession, err)
}

func (suite *SessionServiceTestSuite) TestValidateSessionWithContext() {
	userID := uuid.New()
	ipAddress := "192.168.1.1"
	userAgent := "test-agent"

	// Create session with IP and UA
	createdSession, err := suite.service.CreateSession(suite.ctx, userID, "testuser", &ipAddress, &userAgent, nil)
	assert.NoError(suite.T(), err)

	// Validate with correct context
	validSession, err := suite.service.ValidateSessionWithContext(suite.ctx, createdSession.UUID, ipAddress, userAgent)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), createdSession.UUID, validSession.UUID)

	// Validate with wrong IP
	_, err = suite.service.ValidateSessionWithContext(suite.ctx, createdSession.UUID, "10.0.0.1", userAgent)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrInvalidSession, err)

	// Validate with wrong UA
	_, err = suite.service.ValidateSessionWithContext(suite.ctx, createdSession.UUID, ipAddress, "wrong-agent")
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrInvalidSession, err)
}

func (suite *SessionServiceTestSuite) TestSessionDataOperations() {
	userID := uuid.New()
	createdSession, err := suite.service.CreateSession(suite.ctx, userID, "testuser", nil, nil, nil)
	assert.NoError(suite.T(), err)

	// Set data
	testData := map[string]interface{}{
		"string": "value",
		"number": 42,
		"bool":   true,
		"object": map[string]interface{}{"key": "value"},
	}

	for key, value := range testData {
		err = suite.service.SetSessionData(suite.ctx, createdSession.UUID, key, value)
		assert.NoError(suite.T(), err)
	}

	// Get data
	for key, expectedValue := range testData {
		value, err := suite.service.GetSessionData(suite.ctx, createdSession.UUID, key)
		assert.NoError(suite.T(), err)
		assert.Equal(suite.T(), expectedValue, value)
	}

	// Get non-existent data
	_, err = suite.service.GetSessionData(suite.ctx, createdSession.UUID, "nonexistent")
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrNotFound, err)

	// Delete data
	for key := range testData {
		err = suite.service.DeleteSessionData(suite.ctx, createdSession.UUID, key)
		assert.NoError(suite.T(), err)

		_, err = suite.service.GetSessionData(suite.ctx, createdSession.UUID, key)
		assert.Error(suite.T(), err)
		assert.Equal(suite.T(), errs.ErrNotFound, err)
	}
}

func (suite *SessionServiceTestSuite) TestTemporaryDataOperations() {
	// Set temporary data
	testData := map[string]interface{}{
		"temp1": "value1",
		"temp2": 123,
		"temp3": false,
	}

	for key, value := range testData {
		err := suite.service.SetTemporaryData(suite.ctx, key, value, 1*time.Hour)
		assert.NoError(suite.T(), err)
	}

	// Get temporary data
	for key, expectedValue := range testData {
		value, err := suite.service.GetTemporaryData(suite.ctx, key)
		assert.NoError(suite.T(), err)
		assert.Equal(suite.T(), expectedValue, value)
	}

	// Get non-existent data
	_, err := suite.service.GetTemporaryData(suite.ctx, "nonexistent")
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrNotFound, err)

	// Delete temporary data
	for key := range testData {
		err = suite.service.DeleteTemporaryData(suite.ctx, key)
		assert.NoError(suite.T(), err)

		_, err = suite.service.GetTemporaryData(suite.ctx, key)
		assert.Error(suite.T(), err)
		assert.Equal(suite.T(), errs.ErrNotFound, err)
	}
}

func (suite *SessionServiceTestSuite) TestCheckSessionQuota() {
	userID := uuid.New()
	ipAddress := "192.168.1.1"
	userAgent := "test-agent"

	// Test max user sessions (config is set to 5 in SetupSuite)
	for i := 0; i < 5; i++ {
		err := suite.service.CheckSessionQuota(suite.ctx, userID, &ipAddress, &userAgent)
		assert.NoError(suite.T(), err)

		_, err = suite.service.CreateSession(suite.ctx, userID, "testuser", &ipAddress, &userAgent, nil)
		assert.NoError(suite.T(), err)
	}

	// Should hit max user sessions limit
	err := suite.service.CheckSessionQuota(suite.ctx, userID, &ipAddress, &userAgent)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrForbidden, err)

	// Test max sessions per device (config is set to 3)
	// Create sessions with same user agent but different IP
	for i := 0; i < 3; i++ {
		newIP := fmt.Sprintf("192.168.1.%d", i+2)
		_, err := suite.service.CreateSession(suite.ctx, userID, "testuser", &newIP, &userAgent, nil)
		assert.NoError(suite.T(), err)
	}

	// Should hit max sessions per device limit
	newIP := "192.168.1.100"
	err = suite.service.CheckSessionQuota(suite.ctx, userID, &newIP, &userAgent)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrForbidden, err)

	// Test max IP connections (config is set to 2)
	// Create sessions with same IP but different user agents
	newUserAgent := "other-agent"
	for i := 0; i < 2; i++ {
		ua := fmt.Sprintf("%s-%d", newUserAgent, i)
		_, err := suite.service.CreateSession(suite.ctx, userID, "testuser", &ipAddress, &ua, nil)
		assert.NoError(suite.T(), err)
	}

	// Should hit max IP connections limit
	ua := "another-agent"
	err = suite.service.CheckSessionQuota(suite.ctx, userID, &ipAddress, &ua)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrForbidden, err)
}

func (suite *SessionServiceTestSuite) TestEnforceSessionLimits() {
	userID := uuid.New()
	ipAddress := "192.168.1.1"
	userAgent := "test-agent"

	// With AllowConcurrentSessions=false (set in config), should only allow one session
	firstSession, err := suite.service.CreateSession(suite.ctx, userID, "testuser", &ipAddress, &userAgent, nil)
	assert.NoError(suite.T(), err)

	// Second session should revoke the first one
	secondSession, err := suite.service.CreateSession(suite.ctx, userID, "testuser", &ipAddress, &userAgent, nil)
	assert.NoError(suite.T(), err)

	// Verify first session is revoked
	firstSession, err = suite.service.GetSession(suite.ctx, firstSession.UUID)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), SessionStatusRevoked, firstSession.Status)

	// Verify second session is active
	secondSession, err = suite.service.GetSession(suite.ctx, secondSession.UUID)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), SessionStatusActive, secondSession.Status)

	// Verify only one active session exists
	activeSessions, err := suite.service.GetActiveUserSessions(suite.ctx, userID)
	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), activeSessions, 1)
	assert.Equal(suite.T(), secondSession.UUID, activeSessions[0].UUID)
}

func TestSessionServiceTestSuite(t *testing.T) {
	suite.Run(t, new(SessionServiceTestSuite))
}











import (
	"context"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/gourdian25/gourdiansession/errs"
	"github.com/redis/go-redis/v9"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
)

type RedisRepositoryTestSuite struct {
	suite.Suite
	client     *redis.Client
	repository GurdianSessionRepositoryInt
	ctx        context.Context
}

func (suite *RedisRepositoryTestSuite) SetupSuite() {
	suite.client = redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "GourdianRedisSecret",
		DB:       0,
	})
	suite.repository = NewGurdianRedisSessionRepository(suite.client)
	suite.ctx = context.Background()

	// Flush DB before tests
	err := suite.client.FlushDB(suite.ctx).Err()
	assert.NoError(suite.T(), err)
}

func (suite *RedisRepositoryTestSuite) TearDownTest() {
	// Flush DB after each test
	err := suite.client.FlushDB(suite.ctx).Err()
	assert.NoError(suite.T(), err)
}

func (suite *RedisRepositoryTestSuite) TestCreateAndGetSession() {
	userID := uuid.New()
	username := "testuser"
	ipAddress := "192.168.1.1"
	userAgent := "test-agent"
	roles := []Role{
		{
			Name: "admin",
			Permissions: []Permission{
				{
					Name:     "read",
					Resource: "users",
					Action:   "read",
				},
			},
		},
	}

	// Create a new session
	session := NewGurdianSessionObject(
		userID,
		username,
		&ipAddress,
		&userAgent,
		roles,
		1*time.Hour,
	)

	createdSession, err := suite.repository.CreateSession(suite.ctx, session)
	assert.NoError(suite.T(), err)
	assert.NotNil(suite.T(), createdSession)
	assert.Equal(suite.T(), username, createdSession.Username)
	assert.Equal(suite.T(), userID, createdSession.UserID)
	assert.Equal(suite.T(), ipAddress, *createdSession.IPAddress)
	assert.Equal(suite.T(), userAgent, *createdSession.UserAgent)
	assert.Equal(suite.T(), SessionStatusActive, createdSession.Status)
	assert.True(suite.T(), createdSession.Authenticated)

	// Get the session
	retrievedSession, err := suite.repository.GetSessionByID(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), createdSession.UUID, retrievedSession.UUID)
	assert.Equal(suite.T(), createdSession.UserID, retrievedSession.UserID)
	assert.Equal(suite.T(), createdSession.Username, retrievedSession.Username)
	assert.Equal(suite.T(), *createdSession.IPAddress, *retrievedSession.IPAddress)
	assert.Equal(suite.T(), *createdSession.UserAgent, *retrievedSession.UserAgent)
	assert.Equal(suite.T(), createdSession.Status, retrievedSession.Status)
	assert.Equal(suite.T(), createdSession.Authenticated, retrievedSession.Authenticated)
}

func (suite *RedisRepositoryTestSuite) TestUpdateSession() {
	userID := uuid.New()
	session := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		1*time.Hour,
	)

	createdSession, err := suite.repository.CreateSession(suite.ctx, session)
	assert.NoError(suite.T(), err)

	// Update the session
	createdSession.Username = "updateduser"
	createdSession.Status = SessionStatusRevoked
	updatedSession, err := suite.repository.UpdateSession(suite.ctx, createdSession)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), "updateduser", updatedSession.Username)
	assert.Equal(suite.T(), SessionStatusRevoked, updatedSession.Status)

	// Verify update
	retrievedSession, err := suite.repository.GetSessionByID(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), "updateduser", retrievedSession.Username)
	assert.Equal(suite.T(), SessionStatusRevoked, retrievedSession.Status)
}

func (suite *RedisRepositoryTestSuite) TestDeleteSession() {
	userID := uuid.New()
	session := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		1*time.Hour,
	)

	createdSession, err := suite.repository.CreateSession(suite.ctx, session)
	assert.NoError(suite.T(), err)

	// Delete the session
	err = suite.repository.DeleteSession(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)

	// Verify deletion
	_, err = suite.repository.GetSessionByID(suite.ctx, createdSession.UUID)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrNotFound, err)
}

func (suite *RedisRepositoryTestSuite) TestRevokeSession() {
	userID := uuid.New()
	session := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		1*time.Hour,
	)

	createdSession, err := suite.repository.CreateSession(suite.ctx, session)
	assert.NoError(suite.T(), err)

	// Revoke the session
	err = suite.repository.RevokeSessionByID(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)

	// Verify revocation
	retrievedSession, err := suite.repository.GetSessionByID(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), SessionStatusRevoked, retrievedSession.Status)
	assert.True(suite.T(), time.Now().After(retrievedSession.ExpiresAt))
}

func (suite *RedisRepositoryTestSuite) TestGetSessionsByUserID() {
	userID := uuid.New()
	otherUserID := uuid.New()

	// Create 3 sessions for user
	for i := 0; i < 3; i++ {
		session := NewGurdianSessionObject(
			userID,
			"testuser",
			nil,
			nil,
			nil,
			1*time.Hour,
		)
		_, err := suite.repository.CreateSession(suite.ctx, session)
		assert.NoError(suite.T(), err)
	}

	// Create 2 sessions for other user
	for i := 0; i < 2; i++ {
		session := NewGurdianSessionObject(
			otherUserID,
			"otheruser",
			nil,
			nil,
			nil,
			1*time.Hour,
		)
		_, err := suite.repository.CreateSession(suite.ctx, session)
		assert.NoError(suite.T(), err)
	}

	// Get sessions for user
	sessions, err := suite.repository.GetSessionsByUserID(suite.ctx, userID)
	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), sessions, 3)
	for _, session := range sessions {
		assert.Equal(suite.T(), userID, session.UserID)
	}

	// Get sessions for other user
	otherSessions, err := suite.repository.GetSessionsByUserID(suite.ctx, otherUserID)
	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), otherSessions, 2)
	for _, session := range otherSessions {
		assert.Equal(suite.T(), otherUserID, session.UserID)
	}
}

func (suite *RedisRepositoryTestSuite) TestGetActiveSessionsByUserID() {
	userID := uuid.New()

	// Create active sessions
	for i := 0; i < 2; i++ {
		session := NewGurdianSessionObject(
			userID,
			"testuser",
			nil,
			nil,
			nil,
			1*time.Hour,
		)
		_, err := suite.repository.CreateSession(suite.ctx, session)
		assert.NoError(suite.T(), err)
	}

	// Create expired session
	expiredSession := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		1*time.Hour,
	)
	expiredSession.Status = SessionStatusExpired
	expiredSession.ExpiresAt = time.Now().Add(-1 * time.Hour)
	_, err := suite.repository.CreateSession(suite.ctx, expiredSession)
	assert.NoError(suite.T(), err)

	// Create revoked session
	revokedSession := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		1*time.Hour,
	)
	revokedSession.Status = SessionStatusRevoked
	_, err = suite.repository.CreateSession(suite.ctx, revokedSession)
	assert.NoError(suite.T(), err)

	// Get active sessions
	activeSessions, err := suite.repository.GetActiveSessionsByUserID(suite.ctx, userID)
	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), activeSessions, 2)
	for _, session := range activeSessions {
		assert.Equal(suite.T(), SessionStatusActive, session.Status)
		assert.True(suite.T(), session.ExpiresAt.After(time.Now()))
	}
}

func (suite *RedisRepositoryTestSuite) TestRevokeUserSessions() {
	userID := uuid.New()

	// Create 3 active sessions for user
	for i := 0; i < 3; i++ {
		session := NewGurdianSessionObject(
			userID,
			"testuser",
			nil,
			nil,
			nil,
			1*time.Hour,
		)
		_, err := suite.repository.CreateSession(suite.ctx, session)
		assert.NoError(suite.T(), err)
	}

	// Revoke all sessions
	err := suite.repository.RevokeUserSessions(suite.ctx, userID)
	assert.NoError(suite.T(), err)

	// Verify all sessions are revoked
	sessions, err := suite.repository.GetSessionsByUserID(suite.ctx, userID)
	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), sessions, 3)
	for _, session := range sessions {
		assert.Equal(suite.T(), SessionStatusRevoked, session.Status)
	}
}

func (suite *RedisRepositoryTestSuite) TestRevokeSessionsExcept() {
	userID := uuid.New()
	var keepSessionID uuid.UUID

	// Create 3 active sessions for user
	for i := 0; i < 3; i++ {
		session := NewGurdianSessionObject(
			userID,
			"testuser",
			nil,
			nil,
			nil,
			1*time.Hour,
		)
		createdSession, err := suite.repository.CreateSession(suite.ctx, session)
		assert.NoError(suite.T(), err)
		if i == 1 {
			keepSessionID = createdSession.UUID
		}
	}

	// Revoke all sessions except one
	err := suite.repository.RevokeSessionsExcept(suite.ctx, userID, keepSessionID)
	assert.NoError(suite.T(), err)

	// Verify sessions
	sessions, err := suite.repository.GetSessionsByUserID(suite.ctx, userID)
	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), sessions, 3)

	var keptSession *GourdianSessionType
	for _, session := range sessions {
		if session.UUID == keepSessionID {
			keptSession = session
			assert.Equal(suite.T(), SessionStatusActive, session.Status)
		} else {
			assert.Equal(suite.T(), SessionStatusRevoked, session.Status)
		}
	}
	assert.NotNil(suite.T(), keptSession)
}

func (suite *RedisRepositoryTestSuite) TestExtendSession() {
	userID := uuid.New()
	session := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		1*time.Hour,
	)

	createdSession, err := suite.repository.CreateSession(suite.ctx, session)
	assert.NoError(suite.T(), err)

	originalExpiry := createdSession.ExpiresAt

	// Extend session by 2 hours
	err = suite.repository.ExtendSession(suite.ctx, createdSession.UUID, 2*time.Hour)
	assert.NoError(suite.T(), err)

	// Verify extension
	updatedSession, err := suite.repository.GetSessionByID(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)
	assert.True(suite.T(), updatedSession.ExpiresAt.After(originalExpiry))
	assert.WithinDuration(suite.T(), originalExpiry.Add(2*time.Hour), updatedSession.ExpiresAt, time.Second)
}

func (suite *RedisRepositoryTestSuite) TestUpdateSessionActivity() {
	userID := uuid.New()
	session := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		1*time.Hour,
	)

	createdSession, err := suite.repository.CreateSession(suite.ctx, session)
	assert.NoError(suite.T(), err)

	originalActivity := createdSession.LastActivity

	// Wait a bit to ensure time changes
	time.Sleep(10 * time.Millisecond)

	// Update activity
	err = suite.repository.UpdateSessionActivity(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)

	// Verify update
	updatedSession, err := suite.repository.GetSessionByID(suite.ctx, createdSession.UUID)
	assert.NoError(suite.T(), err)
	assert.True(suite.T(), updatedSession.LastActivity.After(originalActivity))
}

func (suite *RedisRepositoryTestSuite) TestValidateSessionByID() {
	userID := uuid.New()

	// Create active session
	activeSession := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		1*time.Hour,
	)
	createdActiveSession, err := suite.repository.CreateSession(suite.ctx, activeSession)
	assert.NoError(suite.T(), err)

	// Create expired session
	expiredSession := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		-1*time.Hour, // already expired
	)
	createdExpiredSession, err := suite.repository.CreateSession(suite.ctx, expiredSession)
	assert.NoError(suite.T(), err)

	// Create revoked session
	revokedSession := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		1*time.Hour,
	)
	revokedSession.Status = SessionStatusRevoked
	createdRevokedSession, err := suite.repository.CreateSession(suite.ctx, revokedSession)
	assert.NoError(suite.T(), err)

	// Test active session
	validSession, err := suite.repository.ValidateSessionByID(suite.ctx, createdActiveSession.UUID)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), createdActiveSession.UUID, validSession.UUID)
	assert.Equal(suite.T(), SessionStatusActive, validSession.Status)

	// Test expired session
	_, err = suite.repository.ValidateSessionByID(suite.ctx, createdExpiredSession.UUID)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrInvalidSession, err)

	// Test revoked session
	_, err = suite.repository.ValidateSessionByID(suite.ctx, createdRevokedSession.UUID)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrInvalidSession, err)
}

func (suite *RedisRepositoryTestSuite) TestValidateSessionByIDIPUA() {
	userID := uuid.New()
	ipAddress := "192.168.1.1"
	userAgent := "test-agent"

	// Create session with IP and UA
	session := NewGurdianSessionObject(
		userID,
		"testuser",
		&ipAddress,
		&userAgent,
		nil,
		1*time.Hour,
	)
	createdSession, err := suite.repository.CreateSession(suite.ctx, session)
	assert.NoError(suite.T(), err)

	// Test with correct IP and UA
	validSession, err := suite.repository.ValidateSessionByIDIPUA(suite.ctx, createdSession.UUID, ipAddress, userAgent)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), createdSession.UUID, validSession.UUID)

	// Test with wrong IP
	_, err = suite.repository.ValidateSessionByIDIPUA(suite.ctx, createdSession.UUID, "10.0.0.1", userAgent)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrInvalidSession, err)

	// Test with wrong UA
	_, err = suite.repository.ValidateSessionByIDIPUA(suite.ctx, createdSession.UUID, ipAddress, "wrong-agent")
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrInvalidSession, err)
}

func (suite *RedisRepositoryTestSuite) TestSessionDataOperations() {
	userID := uuid.New()
	session := NewGurdianSessionObject(
		userID,
		"testuser",
		nil,
		nil,
		nil,
		1*time.Hour,
	)

	createdSession, err := suite.repository.CreateSession(suite.ctx, session)
	assert.NoError(suite.T(), err)

	// Set data
	testData := map[string]interface{}{
		"string": "value",
		"number": 42,
		"bool":   true,
		"object": map[string]interface{}{"key": "value"},
	}

	for key, value := range testData {
		err = suite.repository.SetSessionData(suite.ctx, createdSession.UUID, key, value)
		assert.NoError(suite.T(), err)
	}

	// Get data
	for key, expectedValue := range testData {
		value, err := suite.repository.GetSessionData(suite.ctx, createdSession.UUID, key)
		assert.NoError(suite.T(), err)
		assert.Equal(suite.T(), expectedValue, value)
	}

	// Get non-existent data
	_, err = suite.repository.GetSessionData(suite.ctx, createdSession.UUID, "nonexistent")
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrNotFound, err)

	// Delete data
	for key := range testData {
		err = suite.repository.DeleteSessionData(suite.ctx, createdSession.UUID, key)
		assert.NoError(suite.T(), err)

		_, err = suite.repository.GetSessionData(suite.ctx, createdSession.UUID, key)
		assert.Error(suite.T(), err)
		assert.Equal(suite.T(), errs.ErrNotFound, err)
	}
}

func (suite *RedisRepositoryTestSuite) TestTemporaryDataOperations() {
	// Set temporary data
	testData := map[string]interface{}{
		"temp1": "value1",
		"temp2": 123,
		"temp3": false,
	}

	for key, value := range testData {
		err := suite.repository.SetTemporaryData(suite.ctx, key, value, 1*time.Hour)
		assert.NoError(suite.T(), err)
	}

	// Get temporary data
	for key, expectedValue := range testData {
		value, err := suite.repository.GetTemporaryData(suite.ctx, key)
		assert.NoError(suite.T(), err)
		assert.Equal(suite.T(), expectedValue, value)
	}

	// Get non-existent data
	_, err := suite.repository.GetTemporaryData(suite.ctx, "nonexistent")
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), errs.ErrNotFound, err)

	// Delete temporary data
	for key := range testData {
		err = suite.repository.DeleteTemporaryData(suite.ctx, key)
		assert.NoError(suite.T(), err)

		_, err = suite.repository.GetTemporaryData(suite.ctx, key)
		assert.Error(suite.T(), err)
		assert.Equal(suite.T(), errs.ErrNotFound, err)
	}
}

func TestRedisRepositoryTestSuite(t *testing.T) {
	suite.Run(t, new(RedisRepositoryTestSuite))
}











import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/redis/go-redis/v9"
	"github.com/stretchr/testify/assert"
)

func setupTestRedis() *redis.Client {
	return redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "GourdianRedisSecret",
		DB:       15,
	})
}

func cleanupTestRedis(t *testing.T, client *redis.Client) {
	ctx := context.Background()
	err := client.FlushDB(ctx).Err()
	assert.NoError(t, err)
}

func TestGourdianSessionIntegration(t *testing.T) {
	ctx := context.Background()
	redisClient := setupTestRedis()
	defer cleanupTestRedis(t, redisClient)

	// Test configuration
	config := &GourdianSessionConfig{
		MaxUserSessions:            5,
		MaxSessionsPerDevice:       2,
		MaxIPConnections:           3,
		AllowConcurrentSessions:    true,
		TrackIPAddresses:           true,
		TrackClientDevices:         true,
		DefaultSessionDuration:     30 * time.Minute,
		IdleTimeoutDuration:        15 * time.Minute,
		SessionRenewalWindow:       5 * time.Minute,
		AutoRevokeOnPasswordChange: true,
		BlockedUserAgents:          []string{"bot", "crawler"},
	}

	// Create service
	service := NewGourdianSession(redisClient, config)

	// Test data
	userID := uuid.New()
	username := "testuser"
	ipAddress := "192.168.1.1"
	userAgent := "test-agent"
	roles := []Role{
		{
			Name: "user",
			Permissions: []Permission{
				{
					Name:     "read",
					Resource: "profile",
					Action:   "read",
				},
			},
		},
	}

	t.Run("Create and Get Session", func(t *testing.T) {
		session, err := service.CreateSession(ctx, userID, username, &ipAddress, &userAgent, roles)
		assert.NoError(t, err)
		assert.NotNil(t, session)
		assert.Equal(t, userID, session.UserID)
		assert.Equal(t, username, session.Username)
		assert.Equal(t, SessionStatusActive, session.Status)
		assert.True(t, session.Authenticated)

		// Get the session
		retrieved, err := service.GetSession(ctx, session.UUID)
		assert.NoError(t, err)
		assert.Equal(t, session.UUID, retrieved.UUID)
	})

	t.Run("Validate Session", func(t *testing.T) {
		session, err := service.CreateSession(ctx, userID, username, &ipAddress, &userAgent, roles)
		assert.NoError(t, err)

		// Validate with just ID
		validSession, err := service.ValidateSession(ctx, session.UUID)
		assert.NoError(t, err)
		assert.Equal(t, session.UUID, validSession.UUID)

		// Validate with context
		validSession, err = service.ValidateSessionWithContext(ctx, session.UUID, ipAddress, userAgent)
		assert.NoError(t, err)
		assert.Equal(t, session.UUID, validSession.UUID)
	})

	t.Run("Session Quota Enforcement", func(t *testing.T) {
		// Create max sessions with different user agents to avoid hitting device limit
		for i := 0; i < config.MaxUserSessions; i++ {
			uniqueUA := fmt.Sprintf("%s-%d", userAgent, i)
			_, err := service.CreateSession(ctx, userID, username, &ipAddress, &uniqueUA, roles)
			assert.NoError(t, err)
		}

		// Next one should fail due to user session limit
		uniqueUA := fmt.Sprintf("%s-%d", userAgent, config.MaxUserSessions)
		_, err := service.CreateSession(ctx, userID, username, &ipAddress, &uniqueUA, roles)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "maximum number of sessions reached for user")
	})

	t.Run("Revoke Sessions", func(t *testing.T) {
		// Use different user agents to avoid hitting device limits
		ua1 := "test-agent-1"
		ua2 := "test-agent-2"

		session1, err := service.CreateSession(ctx, userID, username, &ipAddress, &ua1, roles)
		assert.NoError(t, err)
		session2, err := service.CreateSession(ctx, userID, username, &ipAddress, &ua2, roles)
		assert.NoError(t, err)

		// Revoke one session
		err = service.RevokeSession(ctx, session1.UUID)
		assert.NoError(t, err)

		// Verify revoked session is invalid
		_, err = service.ValidateSession(ctx, session1.UUID)
		assert.Error(t, err)

		// Other session should still be valid
		_, err = service.ValidateSession(ctx, session2.UUID)
		assert.NoError(t, err)

		// Revoke all sessions
		err = service.RevokeAllUserSessions(ctx, userID)
		assert.NoError(t, err)

		// Verify all sessions are revoked
		_, err = service.ValidateSession(ctx, session2.UUID)
		assert.Error(t, err)
	})

	t.Run("Session Data Operations", func(t *testing.T) {
		session, _ := service.CreateSession(ctx, userID, username, &ipAddress, &userAgent, roles)

		// Set data
		err := service.SetSessionData(ctx, session.UUID, "test-key", "test-value")
		assert.NoError(t, err)

		// Get data
		value, err := service.GetSessionData(ctx, session.UUID, "test-key")
		assert.NoError(t, err)
		assert.Equal(t, "test-value", value)

		// Delete data
		err = service.DeleteSessionData(ctx, session.UUID, "test-key")
		assert.NoError(t, err)

		// Verify deleted
		_, err = service.GetSessionData(ctx, session.UUID, "test-key")
		assert.Error(t, err)
	})

	t.Run("Temporary Data Operations", func(t *testing.T) {
		// Set temp data
		err := service.SetTemporaryData(ctx, "temp-key", "temp-value", 1*time.Minute)
		assert.NoError(t, err)

		// Get temp data
		value, err := service.GetTemporaryData(ctx, "temp-key")
		assert.NoError(t, err)
		assert.Equal(t, "temp-value", value)

		// Delete temp data
		err = service.DeleteTemporaryData(ctx, "temp-key")
		assert.NoError(t, err)

		// Verify deleted
		_, err = service.GetTemporaryData(ctx, "temp-key")
		assert.Error(t, err)
	})

	t.Run("Session Refresh", func(t *testing.T) {
		// Create session with short duration
		shortConfig := *config
		shortConfig.DefaultSessionDuration = 2 * time.Second
		shortConfig.SessionRenewalWindow = 1 * time.Second
		shortService := NewGourdianSession(redisClient, &shortConfig)

		session, err := shortService.CreateSession(ctx, userID, username, &ipAddress, &userAgent, roles)
		assert.NoError(t, err)

		originalExpiry := session.ExpiresAt

		// Wait until within renewal window
		time.Sleep(1500 * time.Millisecond)

		// Refresh session
		refreshed, err := shortService.RefreshSession(ctx, session.UUID)
		assert.NoError(t, err)
		assert.True(t, refreshed.ExpiresAt.After(originalExpiry))
	})

	t.Run("Blocked User Agent", func(t *testing.T) {
		blockedUA := "some-bot-user-agent"
		_, err := service.CreateSession(ctx, userID, username, &ipAddress, &blockedUA, roles)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "user agent is blocked")
	})
}
